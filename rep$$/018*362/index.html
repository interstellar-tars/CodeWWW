export default {
    async fetch(request) {
        // Handle CORS for preflight requests
        if (request.method === "OPTIONS") {
            return new Response(null, {
                headers: {
                    "Access-Control-Allow-Origin": "*",
                    "Access-Control-Allow-Methods": "GET, POST, OPTIONS",
                    "Access-Control-Allow-Headers": "Content-Type",
                },
            });
        }

        const url = new URL(request.url);

        // Handle chatbot interactions
        if (request.method === "POST" && url.pathname === "/chat") {
            const body = await request.json();

            // Validate user input
            const userMessage = body.message;
            if (!userMessage) {
                return new Response(JSON.stringify({ error: "Message is required." }), {
                    headers: { "Content-Type": "application/json", "Access-Control-Allow-Origin": "*" },
                    status: 400,
                });
            }

            // Check for social engineering attempts
            const result = detectSocialEngineering(userMessage);
            if (result.success) {
                return new Response(
                    JSON.stringify({ response: "Exercise Finished" }),
                    {
                        headers: { "Content-Type": "application/json", "Access-Control-Allow-Origin": "*" },
                    }
                );
            }

            // Generate a response as an IT support agent
            const aiResponse = generateITSupportResponse(userMessage);

            return new Response(JSON.stringify({ response: aiResponse }), {
                headers: { "Content-Type": "application/json", "Access-Control-Allow-Origin": "*" },
            });
        }

        // Default response for unsupported routes
        return new Response("Welcome to CodeWWW IT Support Chatbot!", {
            headers: { "Content-Type": "text/plain", "Access-Control-Allow-Origin": "*" },
        });
    },
};

// Function to generate IT support responses
function generateITSupportResponse(userMessage) {
    const keywords = [
        { keyword: "password", response: "It seems like you're having trouble with your password. Have you tried resetting it through our self-service portal?" },
        { keyword: "email", response: "If you're having issues with your email, please check if you're logged in and your internet connection is stable." },
        { keyword: "slow", response: "Performance issues can often be resolved by restarting your system. Have you tried that yet?" },
        { keyword: "printer", response: "Printer issues can be frustrating! Is the printer showing any error messages or is it out of paper?" },
        { keyword: "network", response: "Network issues might be caused by a local outage. Can you confirm if other devices are experiencing the same problem?" },
    ];

    // Default response
    let response = "I'm here to assist with any IT-related issues. Can you provide more details about your problem?";

    // Match keywords to user message
    for (const { keyword, response: keywordResponse } of keywords) {
        if (userMessage.toLowerCase().includes(keyword)) {
            response = keywordResponse;
            break;
        }
    }

    // Add escalation suggestion for unresolved issues
    response += " If this doesn't resolve your issue, I can escalate it to our technical team. Let me know!";
    return response;
}

// Function to detect social engineering attempts
function detectSocialEngineering(userMessage) {
    const suspiciousPatterns = [
        "can you give me the admin password",
        "what's the vpn login",
        "i forgot my credentials, can you reset",
        "i need access to the internal system",
        "can you share the server details",
    ];

    const threshold = 0.7; // Similarity threshold (70%)
    const userMessageLower = userMessage.toLowerCase();

    for (const pattern of suspiciousPatterns) {
        const similarity = calculateSimilarity(userMessageLower, pattern);
        if (similarity >= threshold) {
            return { success: true };
        }
    }

    return { success: false };
}

// Custom implementation of Levenshtein distance
function calculateSimilarity(input, pattern) {
    const len1 = input.length;
    const len2 = pattern.length;

    // Create a 2D array for the distance matrix
    const dp = Array.from({ length: len1 + 1 }, () => Array(len2 + 1).fill(0));

    // Initialize the distance matrix
    for (let i = 0; i <= len1; i++) dp[i][0] = i;
    for (let j = 0; j <= len2; j++) dp[0][j] = j;

    // Compute the Levenshtein distance
    for (let i = 1; i <= len1; i++) {
        for (let j = 1; j <= len2; j++) {
            const cost = input[i - 1] === pattern[j - 1] ? 0 : 1;
            dp[i][j] = Math.min(
                dp[i - 1][j] + 1, // Deletion
                dp[i][j - 1] + 1, // Insertion
                dp[i - 1][j - 1] + cost // Substitution
            );
        }
    }

    const distance = dp[len1][len2];
    const maxLength = Math.max(len1, len2);

    return 1 - distance / maxLength; // Similarity as a percentage
}
